CMOV cc dst, src

Условная пересылка

Example:
cmp eax, ecx
cmovg eax, ecx ; eax = min(eax, ecx)

LEA regd, mem
Load Effective Address

Examples:
lea eax, [eax + eax * 4] ; eax *= 5
lea eax, [ebx + ecx + 2] ; Сложение двух регистров и константы одной инструкцией

base + {1, 2, 4, 8} * index + offset
регистр + любой регистр, кроме esp + константа

EFLAGS - регистр флагов

--------------------------------------------------------------------------------

FPU: типы данных

1) Double
64 bits
sign - 63
exponent - [62-52] = 11
fraction - [51-0] = 52

x = (-1) ^ sign * (1 + fraction / (2 ^ 52)) * 2 ^ (exponent - 1023)

2) Single (типо float)
32 bits
exponent - 8 bits
мантисса - 23 bits

3) Extended
80 bits
exponent - 15 bits
fraction - 63 bits
integer part - 63 bits (понимаю, что это типо можно, но не надо)

4) Others

BCD - двоично-десятичное число
80 bits (18 цифр по 4 бита [0-71])
Sign - 79

Special numbers:

НОЛЬ:
1) Целое - просто ноль
2) Дробное - все нули в экспоненте
а) +0, 0 - все биты 0 (просто ноль)
б) -0 (отрицательный ноль) - бит знака 1
в) Денормальные/субнормальные числа - экспонента ноль, мантисса не 0, бит целого - 0

БЕСКОНЕЧНОСТЬ:
1) Экспонента - все единицы
2) бит целого (for 80-bits) - 1
3) мантисса - все нули
4) (не успел :()

НЕОПРЕДЕЛЕННОСТИ:
1) Дробные
a) exponent - all 1
b) integer bit - 1 (for 80-bits)
c) fraction - хотя бы один ненулевой бит
ca) 0XXXX...X - SNan (signalling) - сигнальный NaN
cb) 1XXXX...X - QNan (quiet) - тихий NaN
2) Целые - NaN - 1000...00

--------------------------------------------------------------------------------

FPU: Регистры

80 бит
8 штук
организованы все в стек
ST0 - вершина стека
При инициализации стек пуст

Еще есть регистр статуса (в презентации, вроде умеет проверять, что делает процессор, еще умеет проверять исключения (не те, которые обрабатывает процессор (тоже вроде =)))))

Регистр управления
1 - не вызывается исключение (он что-то такое сказал, но в презентации что-то другое)
Флаг бесконечности там уже не используется, просто исторически остался

Тэг (тЕг же, разве нет?)
Презентация

--------------------------------------------------------------------------------

Передача данных в FPU

FLD/FILD/FBLD
Загружает числа в стек
1) дробное
2) целое
3) двоично-десятичное

Examples:
FLD qword [var] ; так загрузится double (указывем, что 64 бита)
FLD dword [var] ; Single по идее

FST/FSTP/FIST/FISTP/FBSTP

F*ST mem - сохранить st0 в память
F*STP mem - сохранить st0 в память и вынуть из стека

FXCH
FXCH - поменять st0 и st1
Вообще без аргументов работает обычно с st0 и st1
FXCH sti - поменять st0 и stI

FCMOVcc

--------------------------------------------------------------------------------

Константы

FLD1 +1.0
FLDL2T
еще куча примеров

Арифметика

Fop src ; st0 = st0 op src
Fop sti, st0 ; sti = sti op st0
FopR src ; st0 = src op st0
FIop mem ; операция с целым
FIopR mem ; операция с целым, обратный порядок

op = ADD, SUB, MUL, DIV

Сравнение
В презентации вроде норм

Есть еще управляющие инструкции
FWAIT
FINIT/FNINIT
FSTSW/FNSTSW AX/mem16

Тригонометрия (в ассемблере, мдаааа)
FSIN
FCOS
FSINCOS (st0 = cos, st1 = sin)
FPTAN (st0 = 1, st1 = tan) // И снова какая-то история, бла-бла-бла
FPATAN

Еще и логарифмы (ну это уже вообще какая-то хрень)
FYL2X - st1 * log_2(st0) - считает почему-то неточно
FYL2XP1 - умеет кидать исключения (странный он)
Ну а остальное в презентации (надеюсь, что он ее скинет все-таки:))

--------------------------------------------------------------------------------

КОНВЕНЦИИ ВЫЗОВА:

Соглашение о том, как вызывать функции
Для передачи параметров используется стек

Вот основные названия:
cdecl - обычная в Си
stdcall - другая из Си
fastcall - некоторые параметры передаются в регистрах
thiscall - Microsoft
pascal - Pascal

Порядок параметров справа - налево

int foo (int a, int b, int c)
Но стек растет сверху вниз => крутой парадокс

push c
push b
push a
call foo

Сделано для того, чтобы использовать функцию с переменным числом аргументов

c
b
a
return

Если не так, то последний аргумент будет лежать сразу над адресом возврата
А это плохо и неудобно

pascal - наоборот

EBX, ESI, EDI, EBP - регистры сохраняются при вызовах

Возвращаемые значения
EAX - 32 bits
EDX:EAX - 64 bits (double, long long)

cdecl - вызывающий очищает стек
остальные - вызываемый очищает стек

ret n (освободить n бит (ну или очистить))
ret 16, например

cdecl:
    push arg1
    call F
    add ESP, 4 // очищаем выделенные 4 байта, например (под arg1)

остальные:
    push arg1
    call F (он же и очистит 4 байта)

Параметры в регистрах

GNU fastcall, Microsoft fastcall - ECX, EDX
Borland fastcall - EAX, ECX, EDX
Microsoft thiscall - this в ECX
